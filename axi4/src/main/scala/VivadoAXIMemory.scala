/**
 * Author:  Hans Jakob Damsgaard, hansjakobdamsgaard@gmail.com
 * 
 * Purpose: Implementation of a testing framework for AXI4-compliant devices.
 * 
 * Content: A blackbox for an AXI4 block RAM generated by Vivado.
*/

import axi4._
import chisel3._
import chisel3.util._

/** Vivado IP BRAM with full AXI4 interface */
class mymem extends BlackBox with HasBlackBoxResource {
  val io = IO(new Bundle {
    /** Address write */
    val s00_axi_awid      = Input(UInt(1.W))
    val s00_axi_awaddr    = Input(UInt(10.W))
    val s00_axi_awlen     = Input(UInt(8.W))
    val s00_axi_awsize    = Input(UInt(3.W))
    val s00_axi_awburst   = Input(UInt(2.W))
    val s00_axi_awlock    = Input(Bool())
    val s00_axi_awcache   = Input(UInt(4.W))
    val s00_axi_awprot    = Input(UInt(3.W))
    val s00_axi_awregion  = Input(UInt(4.W))
    val s00_axi_awqos     = Input(UInt(4.W))
    val s00_axi_awvalid   = Input(Bool())
    val s00_axi_awready   = Output(Bool())

    /** Data write */
    val s00_axi_wdata     = Input(UInt(32.W))
    val s00_axi_wstrb     = Input(UInt(4.W))
    val s00_axi_wlast     = Input(Bool())
    val s00_axi_wvalid    = Input(Bool())
    val s00_axi_wready    = Output(Bool())

    /** Write response */
    val s00_axi_bid       = Output(UInt(1.W))
    val s00_axi_bresp     = Output(UInt(2.W))
    val s00_axi_bvalid    = Output(Bool())
    val s00_axi_bready    = Input(Bool())

    /** Address read */
    val s00_axi_arid      = Input(UInt(1.W))
    val s00_axi_araddr    = Input(UInt(10.W))
    val s00_axi_arlen     = Input(UInt(8.W))
    val s00_axi_arsize    = Input(UInt(3.W))
    val s00_axi_arburst   = Input(UInt(2.W))
    val s00_axi_arlock    = Input(Bool())
    val s00_axi_arcache   = Input(UInt(4.W))
    val s00_axi_arprot    = Input(UInt(3.W))
    val s00_axi_arregion  = Input(UInt(4.W))
    val s00_axi_arqos     = Input(UInt(4.W))
    val s00_axi_arvalid   = Input(Bool())
    val s00_axi_arready   = Output(Bool())

    /** Data read */
    val s00_axi_rid       = Output(UInt(1.W))
    val s00_axi_rdata     = Output(UInt(32.W))
    val s00_axi_rresp     = Output(UInt(2.W))
    val s00_axi_rlast     = Output(Bool())
    val s00_axi_rvalid    = Output(Bool())
    val s00_axi_rready    = Input(Bool())

    /** Clock and reset */
    val s00_axi_aclk      = Input(Clock())
    val s00_axi_aresetn   = Input(Reset())
  })

  /** Verilog files in /src/main/resources - top file is mymem.v */
  addResource("/mymem.v")
  addResource("/myaximem_v1_0.v")
  addResource("/myaximem_v1_0_S00_AXI.v")
}

/** Wrapper for mymem */
class VivadoAXIMemory extends Slave(1, 10, 32) {
  /** Instantiate a memory */
  val mem = Module(new mymem())

  /** Connect it up with the slave's AXI interface */
  val aw = io.aw.bits
  val dw = io.dw.bits
  val wr = io.wr.bits
  val ar = io.ar.bits
  val dr = io.dr.bits
  
  /** Address write */
  mem.io.s00_axi_awid     := aw.id
  mem.io.s00_axi_awaddr   := aw.addr
  mem.io.s00_axi_awlen    := aw.len
  mem.io.s00_axi_awsize   := aw.size
  mem.io.s00_axi_awburst  := aw.burst
  mem.io.s00_axi_awlock   := aw.lock
  mem.io.s00_axi_awcache  := aw.cache
  mem.io.s00_axi_awprot   := aw.prot
  mem.io.s00_axi_awregion := aw.region
  mem.io.s00_axi_awqos    := aw.qos
  mem.io.s00_axi_awvalid  := io.aw.valid
  io.aw.ready := mem.io.s00_axi_awready

  /** Data write */
  mem.io.s00_axi_wdata    := dw.data
  mem.io.s00_axi_wstrb    := dw.strb
  mem.io.s00_axi_wlast    := dw.last
  mem.io.s00_axi_wvalid   := io.dw.valid
  io.dw.ready := mem.io.s00_axi_wready

  /** Write response */
  wr.id := mem.io.s00_axi_bid 
  wr.resp := mem.io.s00_axi_bresp 
  io.wr.valid := mem.io.s00_axi_bvalid
  mem.io.s00_axi_bready   := io.wr.ready

  /** Address read */
  mem.io.s00_axi_arid     := ar.id
  mem.io.s00_axi_araddr   := ar.addr
  mem.io.s00_axi_arlen    := ar.len
  mem.io.s00_axi_arsize   := ar.size
  mem.io.s00_axi_arburst  := ar.burst
  mem.io.s00_axi_arlock   := ar.lock
  mem.io.s00_axi_arcache  := ar.cache
  mem.io.s00_axi_arprot   := ar.prot
  mem.io.s00_axi_arregion := ar.region
  mem.io.s00_axi_arqos    := ar.qos
  mem.io.s00_axi_arvalid  := io.ar.valid
  io.ar.ready := mem.io.s00_axi_arready

  /** Data read */
  dr.id := mem.io.s00_axi_rid
  dr.data := mem.io.s00_axi_rdata 
  dr.resp := mem.io.s00_axi_rresp 
  dr.last := mem.io.s00_axi_rlast 
  io.dr.valid := mem.io.s00_axi_rvalid
  mem.io.s00_axi_rready   := io.dr.ready

  /** Clock and reset */
  mem.io.s00_axi_aclk     := clock
  mem.io.s00_axi_aresetn  := reset
}
