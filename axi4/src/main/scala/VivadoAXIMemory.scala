/**
 * Author:  Hans Jakob Damsgaard, hansjakobdamsgaard@gmail.com
 * 
 * Purpose: Implementation of a testing framework for AXI4-compliant devices.
 * 
 * Content: A blackbox for an AXI4 block RAM generated by Vivado.
*/

import axi4._
import chisel3._
import chisel3.util._

/** Vivado IP BRAM with full AXI4 interface */
class mymem extends BlackBox with HasBlackBoxResource {
  val io = IO(new Bundle {
    /** Address write */
    val s00_axi_awid      = Input(UInt(1.W))
    val s00_axi_awaddr    = Input(UInt(10.W))
    val s00_axi_awlen     = Input(UInt(8.W))
    val s00_axi_awsize    = Input(UInt(3.W))
    val s00_axi_awburst   = Input(UInt(2.W))
    val s00_axi_awlock    = Input(Bool())
    val s00_axi_awcache   = Input(UInt(4.W))
    val s00_axi_awprot    = Input(UInt(3.W))
    val s00_axi_awregion  = Input(UInt(4.W))
    val s00_axi_awqos     = Input(UInt(4.W))
    val s00_axi_awvalid   = Input(Bool())
    val s00_axi_awready   = Output(Bool())

    /** Data write */
    val s00_axi_wdata     = Input(UInt(32.W))
    val s00_axi_wstrb     = Input(UInt(4.W))
    val s00_axi_wlast     = Input(Bool())
    val s00_axi_wvalid    = Input(Bool())
    val s00_axi_wready    = Output(Bool())

    /** Write response */
    val s00_axi_bid       = Output(UInt(1.W))
    val s00_axi_bresp     = Output(UInt(2.W))
    val s00_axi_bvalid    = Output(Bool())
    val s00_axi_bready    = Input(Bool())

    /** Address read */
    val s00_axi_arid      = Input(UInt(1.W))
    val s00_axi_araddr    = Input(UInt(10.W))
    val s00_axi_arlen     = Input(UInt(8.W))
    val s00_axi_arsize    = Input(UInt(3.W))
    val s00_axi_arburst   = Input(UInt(2.W))
    val s00_axi_arlock    = Input(Bool())
    val s00_axi_arcache   = Input(UInt(4.W))
    val s00_axi_arprot    = Input(UInt(3.W))
    val s00_axi_arregion  = Input(UInt(4.W))
    val s00_axi_arqos     = Input(UInt(4.W))
    val s00_axi_arvalid   = Input(Bool())
    val s00_axi_arready   = Output(Bool())

    /** Data read */
    val s00_axi_rid       = Output(UInt(1.W))
    val s00_axi_rdata     = Output(UInt(32.W))
    val s00_axi_rresp     = Output(UInt(2.W))
    val s00_axi_rlast     = Output(Bool())
    val s00_axi_rvalid    = Output(Bool())
    val s00_axi_rready    = Input(Bool())

    /** Clock and reset */
    val s00_axi_aclk      = Input(Clock())
    val s00_axi_aresetn   = Input(Reset())
  })

  /** Verilog files in /src/main/resources - top file is mymem.v */
  addResource("/mymem.v")
  addResource("/myaximem_v1_0.v")
  addResource("/myaximem_v1_0_S00_AXI.v")
}

/** Wrapper for mymem */
class VivadoAXIMemory extends Slave(10, 32, 1) {
  /** Instantiate a memory */
  val mem = Module(new mymem())

  /** Connect it up with the slave's AXI interface */
  val wa = io.wa.bits
  val wd = io.wd.bits
  val wr = io.wr.bits
  val ra = io.ra.bits
  val rd = io.rd.bits
  
  /** Address write */
  mem.io.s00_axi_awid     := wa.id
  mem.io.s00_axi_awaddr   := wa.addr
  mem.io.s00_axi_awlen    := wa.len
  mem.io.s00_axi_awsize   := wa.size
  mem.io.s00_axi_awburst  := wa.burst
  mem.io.s00_axi_awlock   := wa.lock
  mem.io.s00_axi_awcache  := wa.cache
  mem.io.s00_axi_awprot   := wa.prot
  mem.io.s00_axi_awregion := wa.region
  mem.io.s00_axi_awqos    := wa.qos
  // Leave user port unconnected
  mem.io.s00_axi_awvalid  := io.wa.valid
  io.wa.ready := mem.io.s00_axi_awready

  /** Data write */
  mem.io.s00_axi_wdata    := wd.data
  mem.io.s00_axi_wstrb    := wd.strb
  mem.io.s00_axi_wlast    := wd.last
  // Leave user port unconnected
  mem.io.s00_axi_wvalid   := io.wd.valid
  io.wd.ready := mem.io.s00_axi_wready

  /** Write response */
  wr.id := mem.io.s00_axi_bid 
  wr.resp := mem.io.s00_axi_bresp 
  // Connect user port to constant 0
  wr.user := 0.U
  io.wr.valid := mem.io.s00_axi_bvalid
  mem.io.s00_axi_bready   := io.wr.ready

  /** Address read */
  mem.io.s00_axi_arid     := ra.id
  mem.io.s00_axi_araddr   := ra.addr
  mem.io.s00_axi_arlen    := ra.len
  mem.io.s00_axi_arsize   := ra.size
  mem.io.s00_axi_arburst  := ra.burst
  mem.io.s00_axi_arlock   := ra.lock
  mem.io.s00_axi_arcache  := ra.cache
  mem.io.s00_axi_arprot   := ra.prot
  mem.io.s00_axi_arregion := ra.region
  mem.io.s00_axi_arqos    := ra.qos
  // Leave user port unconnected
  mem.io.s00_axi_arvalid  := io.ra.valid
  io.ra.ready := mem.io.s00_axi_arready

  /** Data read */
  rd.id := mem.io.s00_axi_rid
  rd.data := mem.io.s00_axi_rdata 
  rd.resp := mem.io.s00_axi_rresp 
  rd.last := mem.io.s00_axi_rlast 
  // Connect user port to constant 0
  rd.user := 0.U
  io.rd.valid := mem.io.s00_axi_rvalid
  mem.io.s00_axi_rready   := io.rd.ready

  /** Clock and reset */
  mem.io.s00_axi_aclk     := clock
  mem.io.s00_axi_aresetn  := reset
}
